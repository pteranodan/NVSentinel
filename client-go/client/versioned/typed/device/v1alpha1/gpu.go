//  Copyright (c) 2025, NVIDIA CORPORATION.  All rights reserved.
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

// Code generated by client-gen. DO NOT EDIT.

package v1alpha1

import (
	context "context"

	logr "github.com/go-logr/logr"
	devicev1alpha1 "github.com/nvidia/nvsentinel/api/device/v1alpha1"
	pb "github.com/nvidia/nvsentinel/api/gen/go/device/v1alpha1"
	nvgrpc "github.com/nvidia/nvsentinel/client-go/nvgrpc"
	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	runtime "k8s.io/apimachinery/pkg/runtime"
	watch "k8s.io/apimachinery/pkg/watch"
)

// GPUsGetter has a method to return a GPUInterface.
// A group's client should implement this interface.
type GPUsGetter interface {
	GPUs() GPUInterface
}

// GPUInterface has methods to work with GPU resources.
type GPUInterface interface {
	Get(ctx context.Context, name string, opts v1.GetOptions) (*devicev1alpha1.GPU, error)
	List(ctx context.Context, opts v1.ListOptions) (*devicev1alpha1.GPUList, error)
	Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error)
	GPUExpansion
}

// gpus implements GPUInterface
type gpus struct {
	client pb.GpuServiceClient
	logger logr.Logger
}

// newGPUs returns a gpus
func newGPUs(c *DeviceV1alpha1Client) *gpus {
	return &gpus{
		client: pb.NewGpuServiceClient(c.ClientConn()),
		logger: c.logger.WithName("gpus"),
	}
}

func (c *gpus) getNamespace() string {
	if c == nil {
		return ""
	}
	return ""
}

func (c *gpus) Get(ctx context.Context, name string, opts v1.GetOptions) (*devicev1alpha1.GPU, error) {
	resp, err := c.client.GetGpu(ctx, &pb.GetGpuRequest{
		Name: name,
		Opts: &pb.GetOptions{
			ResourceVersion: opts.ResourceVersion,
			Namespace:       c.getNamespace(),
		},
	})
	if err != nil {
		return nil, err
	}

	obj := devicev1alpha1.FromProto(resp.GetGpu())
	c.logger.V(6).Info("Fetched GPU",
		"name", name,
		"namespace", c.getNamespace(),
		"resource-version", obj.GetResourceVersion(),
	)

	return obj, nil
}

func (c *gpus) List(ctx context.Context, opts v1.ListOptions) (*devicev1alpha1.GPUList, error) {
	resp, err := c.client.ListGpus(ctx, &pb.ListGpusRequest{
		Opts: &pb.ListOptions{
			ResourceVersion: opts.ResourceVersion,
			Namespace:       c.getNamespace(),
		},
	})
	if err != nil {
		return nil, err
	}

	list := devicev1alpha1.FromProtoList(resp.GetGpuList())
	c.logger.V(5).Info("Listed GPUs",
		"namespace", c.getNamespace(),
		"count", len(list.Items),
		"resource-version", list.GetResourceVersion(),
	)

	return list, nil
}

func (c *gpus) Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error) {
	c.logger.V(4).Info("Opening watch stream",
		"resource", "gpus",
		"namespace", c.getNamespace(),
		"resource-version", opts.ResourceVersion,
	)

	ctx, cancel := context.WithCancel(ctx)
	stream, err := c.client.WatchGpus(ctx, &pb.WatchGpusRequest{
		Opts: &pb.ListOptions{
			ResourceVersion: opts.ResourceVersion,
			Namespace:       c.getNamespace(),
		},
	})
	if err != nil {
		cancel()
		return nil, err
	}

	return nvgrpc.NewWatcher(&gpusStreamAdapter{stream: stream}, cancel, c.logger), nil
}

// gpusStreamAdapter wraps the GPU gRPC stream to provide events.
type gpusStreamAdapter struct {
	stream pb.GpuService_WatchGpusClient
}

func (a *gpusStreamAdapter) Next() (string, runtime.Object, error) {
	resp, err := a.stream.Recv()
	if err != nil {
		return "", nil, err
	}

	obj := devicev1alpha1.FromProto(resp.GetObject())

	return resp.GetType(), obj, nil
}

func (a *gpusStreamAdapter) Close() error {
	return a.stream.CloseSend()
}
